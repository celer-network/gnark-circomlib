package circuits

import (
	"github.com/consensys/gnark/frontend"
	"math/big"
)

func Sigma(api frontend.API, in frontend.Variable) frontend.Variable {
	in2 := api.Mul(in, in)
	in4 := api.Mul(in2, in2)
	return api.Mul(in4, in)
}

func Ark(api frontend.API, in []frontend.Variable, c []*big.Int, r int) []frontend.Variable {
	out := make([]frontend.Variable, len(in))
	for i, v := range in {
		out[i] = api.Add(v, c[i+r])
	}
	return out
}

func Mix(api frontend.API, in []frontend.Variable, m [][]*big.Int) []frontend.Variable {
	t := len(in)
	out := make([]frontend.Variable, t)
	for i := 0; i < t; i++ {
		lc := frontend.Variable(0)
		for j := 0; j < t; j++ {
			lc = api.Add(lc, api.Mul(m[j][i], in[j]))
		}
		out[i] = lc
	}
	return out
}

func MixLast(api frontend.API, in []frontend.Variable, m [][]*big.Int, s int) frontend.Variable {
	t := len(in)
	out := frontend.Variable(0)
	for j := 0; j < t; j++ {
		out = api.Add(out, api.Mul(m[j][s], in[j]))
	}
	return out
}

func MixS(api frontend.API, in []frontend.Variable, s []*big.Int, r int) []frontend.Variable {
	t := len(in)
	out := make([]frontend.Variable, t)
	lc := frontend.Variable(0)
	for i := 0; i < t; i++ {
		lc = api.Add(lc, api.Mul(s[(t*2-1)*r+i], in[i]))
	}
	out[0] = lc
	for i := 1; i < t; i++ {
		out[i] = api.Add(in[i], api.Mul(in[0], s[(t*2-1)*r+t+i-1]))
	}
	return out
}

func PoseidonEx(api frontend.API, inputs []frontend.Variable, initialState frontend.Variable, nOuts int) []frontend.Variable {
	nInputs := len(inputs)
	out := make([]frontend.Variable, nOuts)

	// Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
	// Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
	// And rounded up to nearest integer that divides by t
	nRoundsPC := [16]int{56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68}
	t := nInputs + 1
	nRoundsF := 8
	nRoundsP := nRoundsPC[t-2]
	c := POSEIDON_C(t)
	s := POSEIDON_S(t)
	m := POSEIDON_M(t)
	p := POSEIDON_P(t)

	ark0In := make([]frontend.Variable, t)
	for j := 0; j < t; j++ {
		if j == 0 {
			ark0In[0] = initialState
		} else {
			ark0In[j] = inputs[j-1]
		}
	}
	ark0Out := Ark(api, ark0In, c, 0)

	var (
		mixIn     []frontend.Variable
		mixOut    []frontend.Variable
		arkIn     []frontend.Variable
		arkOut    []frontend.Variable
		sigmaFIn  []frontend.Variable
		sigmaFOut []frontend.Variable
	)

	for r := 0; r < nRoundsF/2+1; r++ {
		if r == 0 {
			sigmaFIn = ark0Out
		} else {
			sigmaFIn = mixOut
		}
		sigmaFOut = make([]frontend.Variable, t)
		for j := 0; j < t; j++ {
			sigmaFOut[j] = Sigma(api, sigmaFIn[j])
		}
		arkIn = sigmaFOut
		arkOut = Ark(api, arkIn, c, (r+1)*t)
		mixIn = arkOut
		mixOut = Mix(api, mixIn, m)
	}

	sigmaFIn = mixOut
	for j := 0; j < t; j++ {
		sigmaFOut[j] = Sigma(api, sigmaFIn[j])
	}

	arkIn = sigmaFOut
	arkOut = Ark(api, arkIn, c, nRoundsF/2*t)
	mixIn = arkOut
	mixOut = Mix(api, mixIn, p)

	var (
		sigmaPIn  frontend.Variable
		sigmaPOut frontend.Variable
		mixSIn    []frontend.Variable
		mixSOut   []frontend.Variable
	)
	for r := 0; r < nRoundsP; r++ {
		if r == 0 {
			sigmaPIn = mixOut[0]
		} else {
			sigmaPIn = mixSOut[0]
		}
		sigmaPOut = Sigma(api, sigmaPIn)

		mixSIn = make([]frontend.Variable, t)
		for j := 0; j < t; j++ {
			if j == 0 {
				mixSIn[j] = api.Add(sigmaPOut, c[nRoundsF/2+1+r])
			} else {
				if r == 0 {
					mixSIn[j] = mixOut[j]
				}else {
					mixSIn[j] = mixSOut[j]
				}
			}
		}
		mixSOut = MixS(api, mixSIn, s, r)
	}

	for r := 0; r < nRoundsF/2-1; r++ {
		if r == 0 {
			sigmaFIn = mixSOut
		} else {
			sigmaFIn = mixOut
		}
		for j := 0; j < t; j++ {
			sigmaFOut[j] = Sigma(api, sigmaFIn[j])
		}
		arkIn = sigmaFOut
		arkOut = Ark(api, arkIn, c, (nRoundsF/2+1)*t+nRoundsP+r*t)
		mixIn = arkOut
		mixOut = Mix(api, mixIn, m)
	}
	sigmaFIn = mixOut
	for j := 0; j < t; j++ {
		sigmaFOut[j] = Sigma(api, sigmaFIn[j])
	}
	for i := 0; i < nOuts; i++ {
		out[i] = MixLast(api, sigmaFOut, m, i)
	}
	return out
}

func Poseidon(api frontend.API, inputs []frontend.Variable) frontend.Variable {
	out := PoseidonEx(api, inputs, 0, 1)
	return out[0]
}
